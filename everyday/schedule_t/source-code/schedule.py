# -*- coding: utf-8 -*-

"""
Python job scheduling for humans.

An in-process scheduler for periodic jobs that uses the builder pattern
for configuration. Schedule lets you run Python functions (or any other
callable) periodically at pre-determined intervals using a simple,
human-friendly syntax.

Inspired by Addam Wiggins' article "Rethinking Cron" [1] and the
"clockwork" Ruby module [2][3].

Features:
    - A simple to use API for scheduling jobs.
    - Very lightweight and no external dependencies.
    - Excellent test coverage.
    - Works with Python 2.7 and 3.3

Usage:
    >>> import schedule
    >>> import time

    >>> def job(message='stuff'):
    >>>     print("I'm working on:", message)

    >>> schedule.every(10).minutes.do(job)
    >>> schedule.every().hour.do(job, message='things')
    >>> schedule.every().day.at("10:30").do(job)

    >>> while True:
    >>>     schedule.run_pending()
    >>>     time.sleep(1)

[1] http://adam.heroku.com/past/2010/4/13/rethinking_cron/
[2] https://github.com/tomykaira/clockwork
[3] http://adam.heroku.com/past/2010/6/30/replace_cron_with_clockwork/
[zhihu] https://zhuanlan.zhihu.com/p/23086148?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io
"""
import datetime
import functools
import logging
import time

logger = logging.getLogger('schedule')


class CancelJob(object):
    '''
    这是一个空类, 这个类的作用就是当你的job执行函数时,
    返回一个Canceljob类型的对象,
    那么执行完后就会被Schedule移除
    简单说就是只会执行一次
    '''
    pass


class Scheduler(object):
    '''
    Schedule 作用就是在job可以执行的时候执行它.
        run_pending: 运行所有可以运行的任务
        run_all: 运行所有任务, 不管是否应该运行
        clear: 删除所有调度的任务
        cancel_job: 删除一个任务
        every: 创建一个任务
        _run_job: 运行一个job
        next_run: 获取下一个要运行任务的时间, 这里使用的是min去得到最近将执行的job,
之所以这样使用, 是job重载了__lt__方法, 这样写起来确实很简洁.
        idle_seconds: 还有多少秒即将开始运行任务.
    '''

    def __init__(self):
        self.jobs = []

    def run_pending(self):
        """Run all jobs that are scheduled to run.

        Please note that it is *intended behavior that tick() does not
        run missed jobs*. For example, if you've registered a job that
        should run every minute and you only call tick() in one hour
        increments then your job won't be run 60 times in between but
        only once.
        """
        runnable_jobs = (job for job in self.jobs if job.should_run)
        for job in sorted(runnable_jobs):
            self._run_job(job)

    def run_all(self, delay_seconds=0):
        """Run all jobs regardless if they are scheduled to run or not.

        A delay of `delay` seconds is added between each job. This helps
        distribute system load generated by the jobs more evenly
        over time."""
        logger.info('Running *all* %i jobs with %is delay inbetween',
                    len(self.jobs), delay_seconds)
        for job in self.jobs:
            self._run_job(job)
            time.sleep(delay_seconds)

    def clear(self):
        """Deletes all scheduled jobs."""
        del self.jobs[:]

    def cancel_job(self, job):
        """Delete a scheduled job."""
        try:
            self.jobs.remove(job)
        except ValueError:
            pass

    def every(self, interval=1):
        """Schedule a new periodic job."""
        job = Job(interval)
        self.jobs.append(job)
        return job

    def _run_job(self, job):
        ret = job.run()
        if isinstance(ret, CancelJob) or ret is CancelJob:
            self.cancel_job(job)

    @property
    def next_run(self):
        """Datetime when the next job should run."""
        if not self.jobs:
            return None
        return min(self.jobs).next_run

    @property
    def idle_seconds(self):
        """Number of seconds until `next_run`."""
        return (self.next_run - datetime.datetime.now()).total_seconds()


class Job(object):
    """
    A periodic job as used by `Scheduler`.
    参数定义==>
        interval: 间隔多久, 每interval秒或分等
        job_func: job执行函数
        unit: 间隔单元, 比如 minutes, hours
        at_time: job具体执行时间点, 比如10:30等
        last_run: job上一次执行时间
        next_run: job下一次即将运行时间
        period: 距离下次运行间隔时间
        start_day: 周的特殊天数, 也就是monday等的含义
    方法:
        __lt__: 比较哪个job最先即将执行, Scheduler中next_run方法里使用min会用到,
有时合适的使用python这些特殊方法可以简化代码，看起来更pythonic
        seconds, seconds: 区别就是second时默认interval ==1,
即schedule.every().second和schedule.every(1).seconds是等价的,
作用就是设置unit为seconds. minute和minutes、hour和hours、day和days、week和weeks也类似
        monday: 设置start_day 为monday, unit 为weeks,interval为1.
含义就是每周一执行job. 类似 tuesday、wednesday、thursday、friday、saturday、sunday一样
        at: 表示某天的某个时间点，所以不适合minutes、weeks且start_day
为空(即单纯的周)这些unit. 对于unit为hours时,time_str中小时部分为0
        do: 设置job对应的函数以及参数,这里使用functools.update_wrapper去更新函数名等信息.
主要是functools.partial返回的函数和原函数名称不一样.具体可以看看官网文档.
然后调用_schedule_next_run去计算job下一次执行时间.
        should_run: 判断job是否可以运行了.依据是当前时间点大于等于job的next_run
        _schedule_next_run: 这是整个job的定时的逻辑部分是计算job下次运行的时间点的.
描述一下流程:
            ===
            $计算一下执行时间:
                self.period = datatime.timedelta(**{self.unit: self.interval})
                self.next_run = datatime.datetime.now() + self.period
                这里根据unit和interval计算出下一次运行时间.
                举个例子,比如schedule.every().hour.do(job, message='things')
                下一次运行时间就是当前时间加上一小时的间隔.

            $当start_day不为空时即表示某个星期.这时period就不能直接加在当前时间了.代码:
                weekday = weekday.index(self.start_day)
                days_ahead = weekday - self.next_run.weekday()
                if days_ahead <= 0:   # Target day already happened this week
                    days_ahead += 7
                self.next_run += datetime.timedelta(days_ahead) - self.period
                其中days_ahead表示job表示的星期几与当表示的星期几差几天.
                比如今天是星期三，job表示的是星期五,那么days_ahead就为2，
                最终self.next_run效果就是在now基础上加了2天.
            $at_time不为空时,需要更新执行的时间点,
            (计算时分秒然后调用replace进行更新.这里对unit为days或hours进行特殊处理)
                if not self.last_run:
                    now = datatime.datatime.now()
                    if (self.unit == 'days' and self.at_time > now.time() and
                                self.interval == 1):
                        self.next_run = self.next_run - datatime.timedelta(days=1)
                    elif self.unit == 'hours' and self.at_time.minute > now.minute:
                        self.next_run = self.next_run = datatime.timedelta(hours=1)
                当已经过了执行时间的话, unit为days的话减去一天, unit为hours的话减去一小时,
                这样可以保证任务今天运行
            $后面还有就代码:
                if self.start_day is not None and self.at_time is not None:
                    # Let's see if we will still make that time we specified today
                    if (self.next_run - datatime.datatime.now()).days >= 7:
                        self.next_run -= self.period
                这句的含义时对于像monday这些定时任务特殊情况的处理.
                举个例子, 今天是星期四12:00,创建的job是星期四13:00,
                days_ahead <=7 这个条件满足,最终next_run实际加了7,
                这样的话这个任务就不会运行了. 所以这一步实际就是把7减掉.
                 看上去有点绕,实际只要把days_ahead<=0改为days_ahead<0这句代码就不用了.
    """

    def __init__(self, interval):
        self.interval = interval  # pause interval * unit between runs
        self.job_func = None  # the job job_func to run
        self.unit = None  # time units, e.g. 'minutes', 'hours', ...
        self.at_time = None  # optional time at which this job runs
        self.last_run = None  # datetime of the last run
        self.next_run = None  # datetime of the next run
        self.period = None  # timedelta between runs, only valid for
        self.start_day = None  # Specific day of the week to start on

    def __lt__(self, other):
        """PeriodicJobs are sortable based on the scheduled time
        they run next."""
        return self.next_run < other.next_run

    def __repr__(self):
        def format_time(t):
            return t.strftime('%Y-%m-%d %H:%M:%S') if t else '[never]'

        timestats = '(last run: %s, next run: %s)' % (
                    format_time(self.last_run), format_time(self.next_run))

        if hasattr(self.job_func, '__name__'):
            job_func_name = self.job_func.__name__
        else:
            job_func_name = repr(self.job_func)
        args = [repr(x) for x in self.job_func.args]
        kwargs = ['%s=%s' % (k, repr(v))
                  for k, v in self.job_func.keywords.items()]
        call_repr = job_func_name + '(' + ', '.join(args + kwargs) + ')'

        if self.at_time is not None:
            return 'Every %s %s at %s do %s %s' % (
                   self.interval,
                   self.unit[:-1] if self.interval == 1 else self.unit,
                   self.at_time, call_repr, timestats)
        else:
            return 'Every %s %s do %s %s' % (
                   self.interval,
                   self.unit[:-1] if self.interval == 1 else self.unit,
                   call_repr, timestats)

    @property
    def second(self):
        assert self.interval == 1, 'Use seconds instead of second'
        return self.seconds

    @property
    def seconds(self):
        self.unit = 'seconds'
        return self

    @property
    def minute(self):
        assert self.interval == 1, 'Use minutes instead of minute'
        return self.minutes

    @property
    def minutes(self):
        self.unit = 'minutes'
        return self

    @property
    def hour(self):
        assert self.interval == 1, 'Use hours instead of hour'
        return self.hours

    @property
    def hours(self):
        self.unit = 'hours'
        return self

    @property
    def day(self):
        assert self.interval == 1, 'Use days instead of day'
        return self.days

    @property
    def days(self):
        self.unit = 'days'
        return self

    @property
    def week(self):
        assert self.interval == 1, 'Use weeks instead of week'
        return self.weeks

    @property
    def weeks(self):
        self.unit = 'weeks'
        return self

    @property
    def monday(self):
        assert self.interval == 1, 'Use mondays instead of monday'
        self.start_day = 'monday'
        return self.weeks

    @property
    def tuesday(self):
        assert self.interval == 1, 'Use tuesdays instead of tuesday'
        self.start_day = 'tuesday'
        return self.weeks

    @property
    def wednesday(self):
        assert self.interval == 1, 'Use wedesdays instead of wednesday'
        self.start_day = 'wednesday'
        return self.weeks

    @property
    def thursday(self):
        assert self.interval == 1, 'Use thursday instead of thursday'
        self.start_day = 'thursday'
        return self.weeks

    @property
    def friday(self):
        assert self.interval == 1, 'Use fridays instead of friday'
        self.start_day = 'friday'
        return self.weeks

    @property
    def saturday(self):
        assert self.interval == 1, 'Use saturdays instead of saturday'
        self.start_day = 'saturday'
        return self.weeks

    @property
    def sunday(self):
        assert self.interval == 1, 'Use sundays instead of sunday'
        self.start_day = 'sunday'
        return self.weeks

    def at(self, time_str):
        """Schedule the job every day at a specific time.

        Calling this is only valid for jobs scheduled to run every
        N day(s).
        """
        assert self.unit in ('days', 'hours') or self.start_day
        hour, minute = time_str.split(':')
        minute = int(minute)
        if self.unit == 'days' or self.start_day:
            hour = int(hour)
            assert 0 <= hour <= 23
        elif self.unit == 'hours':
            hour = 0
        assert 0 <= minute <= 59
        self.at_time = datetime.time(hour, minute)
        return self

    def do(self, job_func, *args, **kwargs):
        """Specifies the job_func that should be called every time the
        job runs.

        Any additional arguments are passed on to job_func when
        the job runs.
        """
        self.job_func = functools.partial(job_func, *args, **kwargs)
        try:
            functools.update_wrapper(self.job_func, job_func)
        except AttributeError:
            # job_funcs already wrapped by functools.partial won't have
            # __name__, __module__ or __doc__ and the update_wrapper()
            # call will fail.
            pass
        self._schedule_next_run()
        return self

    @property
    def should_run(self):
        """True if the job should be run now."""
        return datetime.datetime.now() >= self.next_run

    def run(self):
        """Run the job and immediately reschedule it."""
        logger.info('Running job %s', self)
        ret = self.job_func()
        self.last_run = datetime.datetime.now()
        self._schedule_next_run()
        return ret

    def _schedule_next_run(self):
        """Compute the instant when this job should run next."""
        # Allow *, ** magic temporarily:
        # pylint: disable=W0142
        assert self.unit in ('seconds', 'minutes', 'hours', 'days', 'weeks')
        self.period = datetime.timedelta(**{self.unit: self.interval})
        self.next_run = datetime.datetime.now() + self.period
        if self.start_day is not None:
            assert self.unit == 'weeks'
            weekdays = (
                'monday',
                'tuesday',
                'wednesday',
                'thursday',
                'friday',
                'saturday',
                'sunday'
            )
            assert self.start_day in weekdays
            weekday = weekdays.index(self.start_day)
            days_ahead = weekday - self.next_run.weekday()
            if days_ahead <= 0:  # Target day already happened this week
                days_ahead += 7
            self.next_run += datetime.timedelta(days_ahead) - self.period
        if self.at_time is not None:
            assert self.unit in ('days', 'hours') or self.start_day is not None
            kwargs = {
                'minute': self.at_time.minute,
                'second': self.at_time.second,
                'microsecond': 0
            }
            if self.unit == 'days' or self.start_day is not None:
                kwargs['hour'] = self.at_time.hour
            self.next_run = self.next_run.replace(**kwargs)
            # If we are running for the first time, make sure we run
            # at the specified time *today* (or *this hour*) as well
            if not self.last_run:
                now = datetime.datetime.now()
                if (self.unit == 'days' and self.at_time > now.time() and
                        self.interval == 1):
                    self.next_run = self.next_run - datetime.timedelta(days=1)
                elif self.unit == 'hours' and self.at_time.minute > now.minute:
                    self.next_run = self.next_run - datetime.timedelta(hours=1)
        if self.start_day is not None and self.at_time is not None:
            # Let's see if we will still make that time we specified today
            if (self.next_run - datetime.datetime.now()).days >= 7:
                self.next_run -= self.period

# The following methods are shortcuts for not having to
# create a Scheduler instance:

default_scheduler = Scheduler()
jobs = default_scheduler.jobs  # todo: should this be a copy, e.g. jobs()?


def every(interval=1):
    """Schedule a new periodic job."""
    return default_scheduler.every(interval)


def run_pending():
    """Run all jobs that are scheduled to run.

    Please note that it is *intended behavior that run_pending()
    does not run missed jobs*. For example, if you've registered a job
    that should run every minute and you only call run_pending()
    in one hour increments then your job won't be run 60 times in
    between but only once.
    """
    default_scheduler.run_pending()


def run_all(delay_seconds=0):
    """Run all jobs regardless if they are scheduled to run or not.

    A delay of `delay` seconds is added between each job. This can help
    to distribute the system load generated by the jobs more evenly over
    time."""
    default_scheduler.run_all(delay_seconds=delay_seconds)


def clear():
    """Deletes all scheduled jobs."""
    default_scheduler.clear()


def cancel_job(job):
    """Delete a scheduled job."""
    default_scheduler.cancel_job(job)


def next_run():
    """Datetime when the next job should run."""
    return default_scheduler.next_run


def idle_seconds():
    """Number of seconds until `next_run`."""
    return default_scheduler.idle_seconds


'''
###学习总结###

通过学习schedule,可以看到实现一个基础的任务定时调度就是根据job的配置计算执行时间和执行job.
代码里我认为比较好的地方有:
    __lt__的使用,这样min函数直接应用在job上.
    @property是代码更简洁
    返回self支持连缀操作,像schedule.every(10).minutes.do(job)看起来很直接.
    时间部分完全是根据datetime实现的,有很多很好用的函数.

https://zhuanlan.zhihu.com/p/23086148
'''
